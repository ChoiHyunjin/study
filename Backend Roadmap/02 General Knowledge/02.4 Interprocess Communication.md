# 4. Interprocess Communication

- [1. Interprocess Communication(IPC)](#1-interprocess-communicationipc)
  - [IPC 방식](#ipc-방식)
- [2. Process Synchronization](#2-process-synchronization)
  - [race condition](#race-condition)
  - [Critical Section Problem](#critical-section-problem)
    - [피더슨 알고리즘](#피더슨-알고리즘)
  - [Synchronization Hardware](#synchronization-hardware)
  - [Mutex lock](#mutex-lock)
  - [세마포어](#세마포어)
- [3. Deadlock](#3-deadlock)
  - [교착상태의 조건](#교착상태의-조건)
  - [교착 상태의 관리](#교착-상태의-관리)
- [출처](#출처)

## 1. Interprocess Communication(IPC)

- 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로
- IPC는 마이크로커널과 나노커널의 디자인 프로세스에 매우 중요

- 필요한 이유
  - 정보 공유 - 동일한 파일을 여러 프로그램에서 쓸 수 있음.
  - 계산 속도 향상 - 병렬 처리로 속도를 향상 시킬 수 있음.
  - 모듈화 - 기능별로 프로세스, 스레드를 나눌 수 있음.
  - 편의성 - 사용자가 동시에 많은 작업을 할 수 있음. e.g. 유튜브 보면서 웹서핑하면서 코딩.

### IPC 방식

![MessagePassing&ShadredMemory](images/02.4%20Interprocess%20Communication_MessagePassing&ShadredMemory.png)

- Shadred Memory
  - 다른 프로세스가 접근 할 수 있는 메모리 영역 생성
  - 매우 빠름
- Message Passing
  - 메시지를 보내서 통신
  - Direct or indirect communication
  - Synchronous or asynchronous communication - block send, block receive
  - Automatic or explicit buffering

|       Method        | Short Description                                                                                                                          |                                             Provided                                              |
| :-----------------: | ------------------------------------------------------------------------------------------------------------------------------------------ | :-----------------------------------------------------------------------------------------------: |
|        File         | 파일                                                                                                                                       |                                      Most operating systems                                       |
|       Signal        | 한 프로세스가 다른 프로세스에게 원격으로 명령을 보내는 것                                                                                  |                                      Most operating systems                                       |
|       Socket        | 동일한 컴퓨터의 다른 프로세스나 다른 컴퓨터로 네트워크 인터페이스를 통해 전송된 데이터 TCP, UDP                                            |                                      Most operating systems                                       |
| Unix domain socket  | 소켓과 유사하지만 커널에서 통신.주소 공간의 파일 시스템을 사용. 여러 프로세스가 하나의 소켓으로 통신 가능.                                 |                              All POSIX operating systems, Windows 10                              |
|    Message queue    | 소켓과 비슷한 데이터 스트림.OS의해 구현. 프로세스 간의 직접 통신 없이 메시지 큐를 읽고 써서 통신.                                          |                                      Most operating systems                                       |
|   Anonymous pipe    | 표준 입출력을 사용하는 단방향 데이터 체널 . OS가 읽기단에서 읽을 때까지 프로세스는 쓰기단에서 버퍼링. 양방향 통신은 두 개의 파이프로 가능. |                                    All POSIX systems, Windows                                     |
|     Named pipe      | 파일처럼 취급되는 파이프. 표준 입출력 대신 파일처럼 Namde pipe를 읽고 씀.                                                                  |                             All POSIX systems, Windows, AmigaOS 2.0+                              |
|  **Shared memory**  | 여러 프로세스가 동일한 메모리 블록에 접근.프로세스가 서로 통신 할 수 있는 공유 버퍼 메모리.                                                |                                    All POSIX systems, Windows                                     |
| **Message passing** | 여러 프로그램이 메시지 대기열 또는 non-OS가 관리하는 채널로 통신. concurrency 모델에서 일반적으로 사용.                                    | Used in LPC, RPC, RMI, and MPI paradigms, Java RMI, CORBA, COM, DDS, MSMQ, MailSlots, QNX, others |
| Memory-mapped file  | RAM에 맵핑된 파일로 스트림으로 출력하는 대신 메모리 주소를 직접 변경/수정.표준 파일과 동일한 이점 공유.                                    |                                    All POSIX systems, Windows                                     |

## 2. Process Synchronization

### race condition

- 여러 개의 프로세스가 공유 자원에 동시에 접근해 결과값이 잘못되는 것.

### Critical Section Problem

- Critical Section - 공유 자원을 사용하는 구역
- 이 섹션의 내용은 한 번에 수행 되어야 함.
- 다른 프로세스가 접근 할 수 없어야 함.

```py
do{
    Entry section   # 크리티컬 섹션에 들어감
    # critical Section
    Exit Section    # 크리티컬 섹션을 나옴
    # remainder section
}
```

해결의 요건

- Mutual Exclusion(상호 배제) - 하나의 프로세스가 들어가면 다른 프로세스 못 들어옴.
- Progress(진행) - 공유 자원을 쓰지 않는 중이면 쓰고 싶은 프로세스가 바로 쓰게 해줌.
- Bounded Waiting(한정 대기) - Starvation을 막기 위해 무한정 대기하면 안됨.

잘못된 해결

```cpp
// lock을 전역 변수 하는 해결법
do{
    while(lock != true);
    // 여기서 컨텍스트 스위칭이 일어나면 문제 발생
    lock == true;
    // Critical Section
    lock = false;
    //Remainder Section
}
```

#### 피더슨 알고리즘

```py
bool flag[2]
int turn

flag[0] = false # false는 임계구역 사용을 원치 않음.
flag[1] = ture
turn = 0        # 0번 프로세스 차례

P0 :
    # Entry section
    flag[0] = ture # 임계 구역 사용을 원함
    turn = 1    # 다음 프로세스
    while(flag[1] and turn == 1):
        # 1이 임계구역을 쓰고, 1번 차례면
        # 1번이 사용 중이므로 busyWait

    # critical Section 시작
    # ...
    # critical Section 끝

    # Exit Section
    flag[0] = false

P1 :
    flag[1] = ture # 임계 구역 사용을 원함
    turn = 0    # 다음 프로세스
    while(flag[0] and turn == 0):
        # 0이 임계구역을 쓰고, 0번 차례면
        # 번이 사용 중이므로 busyWait
    # critical Section
    flag[1] = false
```

### Synchronization Hardware

- atomic 명령어 - 최소 단위 명령어로 한 번에 실행됨.

test_and_set 명령어의 의사코드

```cpp
bool test_and_set(bool *target){
    boolean rv = *target;
    *target = true;
    return rv;
}
```

```cpp
do{
    while(test_and_set(&lock));
    // Critical Section
    lock = false;
    // Remainder Section
}
```

### Mutex lock

- MUTual EXclusion
- acquire()와 release() 원자적으로 수행

```cpp
acquire(){
    while(!availabile); // busy wait
    available = false;
}

release(){
    available = true;
}
```

```cpp
do{
    acquire lock
    // Critical Seciton
    release lock
    // Remainder Section
}
```

### 세마포어

- Mutex에서 boolean대신 int 사용.
- wait()와 signal()은 원자적 실행

```cpp
S = 10; // 초기 리소스 개수, S가 1이면 Mutex와 동일
wait(S){
    while(S<=0);
    S--;
}

signal(S){
    S++;
}
```

## 3. Deadlock

- 두개 이상의 작업이 서로 상대방의 작업이 끝나길 기다리고 있어 아무것도 완료되지 못하는 상태

### 교착상태의 조건

1. 상호배제(Mutual exclusion) - 프로세스들이 요구하는 자원에 대해 배타적 통제권을 요구
2. 점유대기(Hold and wait) - 할당된 자원을 가진 상태에서 다른 자원을 기다림.
3. 비선점(No preemption) - 자원의 사용이 끝날 때까지 OS가 뺏을 수 없음.
4. 순환대기(Circular wait) - 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있음.

### 교착 상태의 관리

- Resource Allocation Graph

  ![Resource_Allocation_Graph](images/02.4%20Interprocess%20Communication_Resource_Allocation_Graph.png)

  - 실선은 현재 자원
  - 점선은 미래의 자원

- 예방
  - 상호배제 제거 - 최소한 하나의 자원은 비공유. 읽기 전용.
  - 점유대기 제거 - 프로세스가 실행 전 다른 프로세스의 모든 자원을 반환
  - 비선점 제거 - 선점 가능한 프로토콜 사용
  - 순환대기 제거 - 자원 유형에 따라 순서 부여
- 회피
  - 자원을 어떻게 요청 할지 추가 정보를 받아 자원 할당 상태를 검사
  - Safe State - 프로세스가 자원을 요청할 때 아무 문제없이 자원을 할당받을 수 있는 상태
  - Resource-Allocation-Graph Algorithm - cycle 생기는지 판단
  - Banker’s Algorithm - 각프로세스의 요구량, 할당량과 시스템의 남은 자원을 계산해 safe-state유지
- 무시
  - 예방, 회피 기법은 성능에 영향이 있으니 데드락 확률이 낮으면 그냥 포기
- 발견
  - 감시/발견 알고리즘으로 체크
  - 발견하면, 프로세스 종료 또는 자원 선점

## 출처

- 프로세스 간 통신 <https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EA%B0%84_%ED%86%B5%EC%8B%A0>
- Inter-process communication <https://en.wikipedia.org/wiki/Inter-process_communication>
- Shared memory Wiki <https://en.wikipedia.org/wiki/Shared_memory>
- Message passing Wiki <https://en.wikipedia.org/wiki/Message_passing>
- [Process] Inter Process Communication (IPC) <https://talkingaboutme.tistory.com/entry/Process-Inter-Process-Communication-IPC>
- [운영체제] Process Synchronization (3) - Mutex Lock, Semaphore <https://jooona.tistory.com/14?category=829164>
- OS는 할껀데 핵심만 합니다. 8편 Critical section (임계 구역) <https://velog.io/@chappi/OS%EB%8A%94-%ED%95%A0%EA%BB%80%EB%8D%B0-%ED%95%B5%EC%8B%AC%EB%A7%8C-%ED%95%A9%EB%8B%88%EB%8B%A4.-8%ED%8E%B8-Critical-section-%EC%9E%84%EA%B3%84-%EA%B5%AC%EC%97%AD>
- Deadlock <https://en.wikipedia.org/wiki/Deadlock>
- [운영체제] Deadlock (1) - Definition <https://jooona.tistory.com/18?category=829164>
- 교착 상태 <https://ko.wikipedia.org/wiki/%EA%B5%90%EC%B0%A9_%EC%83%81%ED%83%9C>
- OS :: 프로세스 동기화 - mutex lock, semaphore <https://hongku.tistory.com/18>
- Deadlock - 정의, 발생 조건, Resource Allocation Graph, Prevention, Avoidance, Detection, Recovery <https://dongdd.tistory.com/63>
