# 07 객체지향 프로그래밍 part2-2

## 5. 다형성

### 5.1 다형성이란?

조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조 할 수 있는 것

```java
class TV{
    boolean power;
    int channel;

    void power()        { power = !power; }
    void channelUp()    { ++channel; }
    void channelDown()  { --channel; }
}

class CaptionTV extends TV{
    String text;
    void caption()  {/*생략*/}
}
```

```java
TV tv = new CaptionTV();
CaptionTV cTv = new CaptionTV();
CaptionTV cTv2 = new TV(); // ERROR

tv.caption();   // ERROR
cTv.caption();
```

둘다 CaptionTV의 인스턴스이지만 참조변수의 타입에 따라 멤버에 접근 가능 여부가 다름.

> 조상타입의 참조변수는 자손타입의 인스턴스를 참조 가능  
> 반대로 자손타입의 참조변수는 조상타입의 인스턴스 참조 불가능

### 5.2 참조변수의 형변환

> 자손타입 -> 조상타입(UP-casting) : 형변환 생략  
> 조상타입 -> 자손타입(DOWN-casting) : 형변환 명시

```java
class Car{
    int door;
    void drive();
}

class FireEngine extends Car{
    void water();
}

class Ambulance extends Car{
    void siren();
}
```

```java
Car car = null;
FireEngine fe = new FireEngine();
FireEngine fe2 = null;
Ambulace am = null;

car = fe;               // 형변환 생략, 업케스팅
fe = (FireEngine)car;   // 형변환 명시, 다운 케스팅
am = (Ambulace)fe;      // ERROR, 형변환 불가
```

상속관계가 아닌 클래스 간의 형변환 불가

```java
Car car = new Car();
FireEngine fe = null;

fe = (FireEngine)car;   // ERROR
```

조상타입의 인스턴스를 받을 수 없음.

### 5.3 instanceof 연산자

인스턴스의 실제 타입을 알아 보기위한 연산자

```java
FireEngine fe = new FireEngine();

fe instanceof FireEngine    // true
fe instanceof Car           // true
fe instanceof object        // true
```

> 어떤 타입의 instanceof연산 값이 true라는 것은 형변환이 가능하다는 뜻

### 5.4 참조변수와 인스턴스 연결

> 메소드는 오버라이드 되지만, 멤버변수는 참조변수의 타입에 따라 달라진다.

```java
class Parent(
    int x = 100;

    void method(){
        System.out.println("Parent");
    }
)
class Child extends Parent(
    int x = 200;

    void method(){
        System.out.println("Child");
        System.out.println(x);      // 100
        System.out.println(this.x); // 100
        System.out.println(super.x);// 200
    }
)

class BindingTest{
    public static void main(String[] args){
        Parent p = new Child();
        Child c = new Child();

        System.out.println(p.x);    // 100
        p.mehtod()                  // Child...
        System.out.println(c.x);    // 200
        c.mehtod()                  // Child...
    }
}
```

### 5.5 매개변수의 다형성

조상타입으로 매개변수를 지정해 자손타입을 모두 받을 수 있음.

```java
class Product{
    int price;
    Product(int price){ this.price = price;}
}
class TV extends Product{
    TV(){ super(100); }
}
class Computer extends Product{
    Computer(){ super(100); }
}

class Buyer{
    int money = 1000;

    void buy(Product p){
        this.money -= p.price;
    }
}

class PolyArgument{
    public static void main(){
        Buyer b = new Buyer();

        b.buy(new TV());
        b.buy(new Computer());

        System.out.println("잔액 : " + b.mony); // 잔액 : 700
    }
}
```

### 5.6 여러 종류의 객체를 배열로 다루기

```java
Product p[] = new Product[3];
p[0] = new TV();
p[1] = new Computer();
p[2] = new Audio();
```

```java
Vector item = new Vector();
item.add(new TV());
item.add(new Computer());
item.add(new Audio());
```

## 6. 추상클래스

### 6.1 추상클래스란?

- 클래스가 설계도라면 추상클래스는 미완성클래스.  
  덜 만들었다는 뜻이 아니라, 미완성 메서드(추상메서드)가 존재하는 클래스.
- 미완성 설계도이므로 인스턴스 생성 불가.
- 상속한 자손 클래스가 완성해야 함.

```java
abstract class 클래스명{
}
```

### 6.2 추상메서드(abstract method)

- 선언만하고 구현하지 않은 메서드.

```java
// 주석으로 어떤 기능을 수행할 목적인지 설명
abstract 리턴 메서드();
```

- 자손 클래스에서 구현이 달라질 수 있음.
- 메서드명, 매개변수, 리턴타입을 결정.
- 구현 전에 추상메서드를 사용하는 코드를 미리 작성 가능.

### 6.3 추상클래스의 작성

> 추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업  
> 구체화 : 상속을 통해 클래스를 구현, 확장하는 작업

- 구체화

  ```java
  abstract class Player{
      int pos;
      abstract void play(int pos);    // 구현을 강요
      void stop(){};                  // 일반메서드
  }
  class class CDPlayer extends Player{
      void play(int pos){
          // 구현 생략
      }
      void stop(){
          // 구현 생략
      }
  }
  ```

- 추상화

  before

  ```java
  class Marine{
      int x, y;
      void move(int x, int y){/*걷기 구현*/}
      void stop(){/*정지*/}
      void stimPack(){/*스팀팩 사용*/}
  }
  class Tank{
      int x, y;
      void move(int x, int y){/*운전 구현*/}
      void stop(){/*정지*/}
      void changeMode(){/*모드 전환*/}
  }
  ```

  after

  ```java
  abstract class Unit{
      int x, y;
      abstract void move(int x, int y);
      void stop(){/*정지*/}
  }
  class Marine extends Unit{
      void move(int x, int y){/*걷기 구현*/}
      void stimPack(){/*스팀팩 사용*/}
  }
  class Tank extends Unit{
      void move(int x, int y){/*운전 구현*/}
      void changeMode(){/*모드 전환*/}
  }
  ```

## 7. 인터페이스

### 7.1 인터페이스란?

일반 메서드, 멤버변수가 없는 추상클래스

### 7.2 인터페이스의 작성

```java
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);

    //제어자를 생략해도 컴파일러가 자동적으로 수정함
    final int A = 3;    // public static final int A = 3;
    static int B = 2;   // public static final int B = 2;
    int C = 1;          // public static final int C = 1;
    String getName();   // public abstract String getName();
}
```

- JDK1.8 이후부터 static메서드와 디폴트 메서드도 가능

### 7.3 인터페이스의 상속

인터페이스는 인터페이스만 상속가능, 다중 상속가능.

```java
interface Movable(){
    void move(int x, int y);
}
interface Attackable(){
    void attack(Unit u);
}
interface Fightable extends Movable, Attackable{}
```

### 7.4 인터페이스의 구현

```java
class 클래스이름 implements 인터페이스이름{
    // 인터페이스에 정의된 추상메서드 구현
}
```

인터페이스를 모두 구현해야 함.  
오버라이딩하면 더 넓은 접근자 지정. 그래서 public

```java
class Fighter implements Fightable{
    public void move(int x, int y){/*구현*/}
    public void attack(Unit u){/*구현*/}
}
```

abstract 클래스 선언 후 일부만 구현.

```java
abstract class Fighter implements Fightable{
    public void move(int x, int y){/*구현*/}
    //attack
}
```

상속과 구현을 동시에

```java
class Fighter extends Unit implements Fightable{
    public void move(int x, int y){/*구현*/}
    public void attack(Unit u){/*구현*/}
}
```

### 7.5 인터페이스를 이용한 다중상속

자바는 다중 상속을 금지.

두 조상 클래스 중 비중이 높은 것을 상속하고, 다른쪽을 클래스 내부에 멤버로 포함시키거나, 필요한 부분을 인터페이스로 만듬.

```java
public class TV{
    protected boolean power;
    protected int channel;

    public void power(){ power = !power; }
    public void channelUp(){ ++channel; }
    public void channelDown(){ --channel; }
}

public class VCR{
    public void play(){/*재생*/}
    public void stop(){/*정지*/}
}
```

```java
public interface IVCR{
    public void play();
    public void stop();
}

public class TVCR extend TV implements IVCR{
    VCR vcr = new VCR();

    public void play(){
        vcr.play();
    }
    public void stop(){
        vcr.stop();
    }
}
```

### 7.6 인터페이스를 이용한 다형성

인터페이스도 클래스의 조상임.

```java
Fightable f = new Fighter();
```

매개변수로 사용

```java
class Fighter extends Unit implements Fightable{
    public void move(int x, int y){/*구현*/}
    public void attack(Fightable f){/*구현*/}
}
```

리턴타입으로 사용

```java
Fightable method(){
    return new Fighter();;
}
```

e.g. ParserManager.getParser

```java
interface Parseable{
    public void parse(String fileName);
}

class ParserManager{
    public static Parseable getParser(String type){
        if(type.equals("XML")){
            return new XMLParser();
        }else{
            return new HTMLParser();
        }
    }
}

class XMLParser implements Parseable{
    public void parse(String fileName){/*구현*/}
}

class HTMLParser implements Parseable{
    public void parse(String fileName){/*구현*/}
}

class ParserTest{
    public static void main(){
        Parseable parser = ParserManager.getParser("XML");
        parser.parse("document.xml");
        Parseable parser = ParserManager.getParser("HTML");
        parser.parse("document.html");
    }
}

```

- 리턴타입이 인터페이스라는 것은 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것

### 7.7 인터페이스의 장점

- 개발 시간 단축

  구현하는 쪽도 호출하는 쪽도 동시에 개발 가능

- 표준화 가능

  기본 틀을 인터페이스로 작성한 다음, 개발자들이 인터페이스를 구현하여 일관되고 정형화된 프로그램 개발 가능

- 서로 관계없는 클래스에게 관계를 맺어줌

  같은 조상클래스가 없더라도 하나의 인터페이스로 공통적으로 구현하도록 함으로써 관계

- 독립적인 프로그래밍이 가능

  클래스의 선언과 구현을 분리.
  인터페이스를 이용해 간접적인 관계로 한 클래스의 변경이 다른 클래스에 영향을 미치지 않음.

e.g.

![interface 계층도](images/07%20interface%20diagram.png)

before

```java
void repair(SCV s){ /*수리*/ }
void repair(Tank t){ /*수리*/ }
void repair(Dropship d){ /*수리*/ }
```

after

```java
void repair(Repairable r){ /*수리*/ }
```

### 7.8 인터페이스의 이해

### 7.9 디폴트 메서드와 static 메서드

## 8. 내부 클래스

### 8.1 내부 클래스란?

### 8.2 내부 클래스의 종류와 특징

### 8.3 내부 클래스의 선언

### 8.4 내부 클래스의 제어자와 접근성

### 8.5 익명 클래스(anonymous class)
